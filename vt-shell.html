<link rel="import" href="./vt-model-element.html">
<script type="text/javascript" src="../underscore/underscore.js"></script>

<!-- events: statusChanged (enqueued, canceled, working, dropped) -->
<polymer-element name="vt-shell" extends="vt-model-element" attributes="commandline output params">
  <template>
    <link rel="stylesheet" href="vt-shell.css"/>
    <div id="shellContainer">
      <template if="{{output}}">
        <div id="viewport"></div>
      </template>
      <div id="shelltasksContainer">
        <content id="content" select="vt-shelltask"></content>
      </div>
      <template if="{{commandline}}">
        <div id="inputbar">
          <input id="commandInput"/>
          <button on-click="{{clickEnqueueCallback}}">Enqueue</button>
        </div>
      </template>
    </div>
  </template>
  <script>
    var ChildProcess = global.require('child_process');
    var Async = global.require('async');
    var _StartTransactionMarker = 'echo V15TStart_';
    var _EndTransactionMarker = 'echo V15TEnd_';
    var _TransactionMarker = '_Trans_';

    function getDependenciesParams(iParam){
      var paramRegex = /\[(\S+?)\]/g;
      var currentResult = null;
      var dependencies = [];
      while(currentResult = paramRegex.exec(iParam)){
        dependencies = dependencies.concat(currentResult[1]);
      }
      return dependencies;
    }

    function getDependenciesGraph(iParams){
      var graph = new Graph();

      function Graph(){
        this.nodeMap = {};
        this._visitId = 0;
      }
      Graph.prototype.getNode = function(iName){
        var node = this.nodeMap[iName];
        if(!node){
          node = this.nodeMap[iName] = new Node(iName);
        }
        return node;
      }
      Graph.prototype.isResolvable = function(){
        for(var nodeIdx in this.nodeMap){
          this._visitId++;
          var currentNode = this.nodeMap[nodeIdx];
          if( ! currentNode.isResolved(this._visitId)){
            return false;
          }
        }
        return true;
      }

      function Node(iName){
        this.name = iName;
        this._resolved = false;
      }
      Node.prototype.addDependency = function(iNode){
        if(!this.dependencies)
          this.dependencies = [];
        this.dependencies = _.union(this.dependencies, [iNode]);
      }
      Node.prototype.isResolved = function(iVisitId){
        if(!this._resolved && (this._visitId == iVisitId)){
          console.log(1)
          return false;
        }
        if(!this._resolved){
          this._visitId = iVisitId;
          for(var depIdx in this.dependencies){
            var currentDep = this.dependencies[depIdx];
            if(!currentDep.isResolved(iVisitId)){
              console.log(3)
              this._resolved = false;
              return false;
            }
          }
          this._resolved = true;          
        }
        return this._resolved;
      }

      for(var paramName in iParams){
        var currentParamNode = graph.getNode(paramName);
        var currentParamValue = iParams[paramName];
        var dependencies = getDependenciesParams(currentParamValue);
        
        for(var dependencyIdx in dependencies){
          var currentDependencyName = dependencies[dependencyIdx];
          var currentDependencyParam = iParams[currentDependencyName];
          if(currentDependencyParam == undefined){
            return null;
          }
          var currentDependencyNode = graph.getNode(currentDependencyName);
          currentParamNode.addDependency(currentDependencyNode);
        }

      }
      return graph;
    }

    // checkParams({'truc':'bidule'})
    function checkParams(iParams){
      var graph = getDependenciesGraph(iParams);
      if(!graph){
        return false;
      }
      var isResolvable = graph.isResolvable();
      if(isResolvable){
      }
      return isResolvable;
    }

    // injectParams('[a] [b]', {'a':'vincent', 'b':'se [c] son/sa [d] avec son/sa [e]', 'c':'tapoter', 'd':'cuisse', 'e':'bouteille plastique'})
    function injectParams(iData, iParams){
      if(!checkParams(iParams)){
        return iData;
      }

      var paramRegexString = '\\[(\\S+?)\\]';
      var paramRegex = new RegExp(paramRegexString, 'g');
      var currentMatch = null;
      while (currentMatch = paramRegex.exec(iData)){
        var paramMatch = currentMatch[1];
        var fullMatchRegex = '\\['+paramMatch+'\\]';
        var re = new RegExp(fullMatchRegex, 'g');
        iData = iData.replace(re, iParams[paramMatch]);
        paramRegex.compile(paramRegexString);
      }
      return iData;
    }

    Polymer('vt-shell',{
      commandline: false,
      output: false,
      params: {},
      created : function(){
        this.queue = Async.queue(this.doShellTask.bind(this), 1);
        this.child_process = ChildProcess.spawn('cmd');
        this.fullOutput = '';
        this.locTransactionId = 0;

        var self = this;
        var stdoutCallback = function(data){
          self.fullOutput += data;
          if(self.output){
            self.$.viewport.innerHTML += self.encodeHTML(data);
          }
          self.fire('stdout_data', data);
        };

        var stderrCallback = function(data){
          self.fullOutput += data;
          if(self.output){
            self.$.viewport.innerHTML += self.encodeHTML(data);
          }
          self.fire('stderr_data', data);
        };
        
        this.child_process.stdout.on('data', stdoutCallback);
        this.child_process.stderr.on('data', stderrCallback);
        this.child_process.on('exit', function(){console.log('child_process exited')});
      },
      encodeHTML : function(iText){
        if(! iText){
          return '';
        }

        if( !(iText.replace) ){
          iText = iText.toString();
        }

        if(iText.replace){
          return iText.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/(\n)/g,'<br/>');
        }else{
          return '';
        }
      },
      rawWrite : function(iData){
        this.child_process.stdin.write(iData);
      },
      write : function(iData){
        var injectedData = injectParams(iData, this.params);

        this.rawWrite(iData);
      },
      doShellTask : function(iShellTaskElt, iCallback){
        console.log('doShellTask');
        var self = this;
        var transactionId = _TransactionMarker+this.locTransactionId;
        
        if(iShellTaskElt.status === 'canceled'){
          iShellTaskElt.setAttribute("status", "dropped");
          iShellTaskElt.remove();
          if(iCallback) iCallback();
          return;
        }

        iShellTaskElt.setAttribute("status", "working");
        this.write(_StartTransactionMarker+iShellTaskElt.elt_id+transactionId+'\n');
        this.write( (iShellTaskElt.command?iShellTaskElt.command:'') + '\n');
        this.write(_EndTransactionMarker+iShellTaskElt.elt_id+transactionId+'\n');

        var dataBuffer='';

        var dataCallback = function(customEvent){
          console.log('dataCallback');
          var stringData = customEvent.detail.toString();
          dataBuffer += stringData;
          if(RegExp(_EndTransactionMarker+iShellTaskElt.elt_id+transactionId).test(stringData)){
            console.log('dataCallbackmatch');
            iShellTaskElt.setAttribute('status','finished');
            iShellTaskElt.remove();
            self.removeEventListener('stdout_data', stdoutCallback);
            self.removeEventListener('stderr_data', stderrCallback);
            self.locTransactionId++;
            
            if(iCallback){
              iCallback(null, dataBuffer);
            }
          }
        };

        var stdoutCallback = function(customEvent){          
          dataCallback(customEvent);
          if(iShellTaskElt.stdoutCallback){
            iShellTaskElt.stdoutCallback(customEvent);
          }
        };

        var stderrCallback = function(customEvent){
          dataCallback(customEvent);
          if(iShellTaskElt.stdoutCallback){
            iShellTaskElt.stdoutCallback(customEvent);
          }
        };

        this.addEventListener('stdout_data', stdoutCallback);
        this.addEventListener('stderr_data', stderrCallback);
      },
      domReady : function(){
        usershelltasks = this.$.content.getDistributedNodes();
        // usershelltasks.forEach(this.addShellTaskElt.bind(this));
        for(var i in usershelltasks){
          this.addShellTaskElt(usershelltasks[i])
        }
      },
      addShellTaskElt : function(iShellTaskElt){
        console.log('addShellTaskElt');
        if(!iShellTaskElt || !iShellTaskElt.setAttribute)
          return;

        iShellTaskElt.setAttribute("status", "enqueued");
        this.$.shelltasksContainer.appendChild(iShellTaskElt);
        this.queue.push(iShellTaskElt);
      },
      addTaskData : function(iTask){
        var newTaskElt = document.createElement('vt-shelltask');        
        newTaskElt.data = iTask;

        this.addShellTaskElt(newTaskElt);
      },
      clickEnqueueCallback : function(){
        var userCmd = this.$.commandInput.value;
        if(!userCmd)
          return;
        
        this.addTaskData({ command: userCmd });
      }
    });
  </script>
</polymer-element>